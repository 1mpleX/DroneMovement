<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Drone Path Predictor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f4f6f8;
            color: #333;
            margin: 0;
            padding: 20px;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
        }

        label {
            font-weight: bold;
            margin-top: 10px;
            display: block;
        }

        input[type="text"],
        input[type="number"] {
            width: 100%;
            padding: 8px;
            margin: 5px 0 15px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 6px;
        }

        .telemetry-block {
            background: #fff;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .telemetry-block button {
            margin-top: 10px;
            background: #e74c3c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
        }

        .telemetry-block button:hover {
            background: #c0392b;
        }

        button {
            background-color: #3498db;
            color: white;
            padding: 10px 16px;
            margin-right: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
        }

        button:hover {
            background-color: #2980b9;
        }

        #response {
            background: #fff;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 6px;
            white-space: pre-wrap;
            margin-top: 20px;
            max-height: 250px;
            overflow-y: auto;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        .styled-select {
            width: 100%;
            padding: 8px;
            margin: 5px 0 15px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 6px;
            background: #fff;
            font-size: 16px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background: #fff url('data:image/svg+xml;utf8,<svg fill="%233498db" height="20" viewBox="0 0 20 20" width="20" xmlns="http://www.w3.org/2000/svg"><path d="M7.293 8.293a1 1 0 011.414 0L10 9.586l1.293-1.293a1 1 0 111.414 1.414l-2 2a1 1 0 01-1.414 0l-2-2a1 1 0 010-1.414z"/></svg>') no-repeat right 12px center/20px 20px;
            padding-right: 40px;
        }
        .styled-select:focus {
            border-color: #3498db;
            outline: none;
        }
        .styled-input {
            width: 100%;
            padding: 8px;
            margin: 5px 0 15px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 6px;
            font-size: 16px;
        }
        .styled-input:focus {
            border-color: #3498db;
            outline: none;
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

</head>
    <body>

    <div class="container">
        <h1>Drone Path Predictor</h1>

        <label>Drone ID:</label>
        <input type="text" id="droneId" value="drone_01"/>

        <label>Drone Type:</label>
        <input type="text" id="droneType" value="quadcopter"/>

        <h2>Telemetry Data</h2>

        <div id="telemetry-container"></div>

        <button onclick="addTelemetryPoint()">Add Telemetry Point</button>
        <button onclick="detectDroneType()">Detect Drone Type</button>
        <br><br>
        <label>–ó–∞–≥—Ä—É–∑–∏—Ç—å JSON —Ñ–∞–π–ª —Å —Ç–µ–ª–µ–º–µ—Ç—Ä–∏–µ–π:</label>
        <input type="file" id="jsonFileInput" accept="application/json"/>
        <button onclick="loadJsonFile()">–ó–∞–≥—Ä—É–∑–∏—Ç—å</button>
        <br><br>
        <label>–°–ø–æ—Å–æ–± –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞:</label>
        <select id="graphMethod" class="styled-select">
            <option value="approximation">–ê–ø–ø—Ä–æ–∫—Å–∏–º–∞—Ü–∏—è</option>
            <option value="interpolation">–ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è</option>
        </select>
        <br><br>
        <label>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞:</label>
        <input type="number" id="pointsLimit" min="2" max="1000" value="4" class="styled-input"/>
        <br><br>
        <button onclick="collectAndCreateGraph()">Create Graph and Predict Path</button>
        <button onclick="stopCalculation()" id="stopBtn">–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ä–∞—Å—á–µ—Ç</button>
        <button onclick="refresh3DVisualization()">–û–±–Ω–æ–≤–∏—Ç—å 3D –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é</button>

        <h2>Server Response</h2>
        <pre id="response">Waiting...</pre>

        <h2>–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–∏</h2>
        <canvas id="deviationChart" width="600" height="300"></canvas>
        <h2>–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥–Ω–æ–∑–∞ –æ—Ç —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏</h2>
        <canvas id="forecastDeviationChart" width="600" height="300"></canvas>
        <h2>–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –ø–æ—Å–ª–µ –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏—è –Ω–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç</h2>
        <canvas id="realtimeDeviationChart" width="600" height="300"></canvas>
        
        <h2>3D –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –¥–≤–∏–∂–µ–Ω–∏—è –¥—Ä–æ–Ω–∞</h2>
        <div id="3d-container" style="width: 100%; height: 500px; border: 1px solid #ccc; border-radius: 6px; position: relative;">
            <canvas id="3dCanvas" style="width: 100%; height: 100%;"></canvas>
            <div id="3d-controls" style="position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 10px; border-radius: 4px;">
                <button onclick="resetCamera()">–°–±—Ä–æ—Å –∫–∞–º–µ—Ä—ã</button>
                <button onclick="toggleAnimation()">–°—Ç–æ–ø/–°—Ç–∞—Ä—Ç</button>
                <div style="margin-top: 10px;">
                    <label>–°–∫–æ—Ä–æ—Å—Ç—å –∞–Ω–∏–º–∞—Ü–∏–∏:</label>
                    <input type="range" id="animationSpeed" min="0.1" max="5" step="0.1" value="1" onchange="updateAnimationSpeed()">
                </div>
                <div style="margin-top: 15px; border-top: 1px solid #ccc; padding-top: 10px;">
                    <strong>–û—Å–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç:</strong><br>
                    <span style="color: #ff0000;">‚óè X (–ö—Ä–∞—Å–Ω–∞—è) - –î–æ–ª–≥–æ—Ç–∞</span><br>
                    <span style="color: #00ff00;">‚óè Y (–ó–µ–ª–µ–Ω–∞—è) - –í—ã—Å–æ—Ç–∞</span><br>
                    <span style="color: #0000ff;">‚óè Z (–°–∏–Ω—è—è) - –®–∏—Ä–æ—Ç–∞</span>
                </div>
                <div style="margin-top: 10px; border-top: 1px solid #ccc; padding-top: 10px;">
                    <strong>–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥—Ä–æ–Ω–∞:</strong><br>
                    <div id="drone-coordinates" style="font-family: monospace; font-size: 12px;">
                        X: 0.000000<br>
                        Y: 0.000000<br>
                        Z: 0.000000
                    </div>
                </div>
            </div>
        </div>
    </div>

        <script>

            window.predictedPath = [];
            window.allTelemetry = [];
            window.baseTelemetry = [];
            window.generatedTelemetry = [];
            window.replayInterval = null;
            window.responseHistory = [];

            function addTelemetryPoint() {
                const container = document.getElementById("telemetry-container");

                const div = document.createElement("div");
                div.className = "telemetry-block";

                div.innerHTML = `
                    <label>Time (seconds):</label>
                    <input type="number" step="0.01" class="time" placeholder="0"/>

                    <label>Longitude:</label>
                    <input type="number" step="0.000001" class="longitude" placeholder="00.000000"/>

                    <label>Latitude:</label>
                    <input type="number" step="0.000001" class="latitude" placeholder="00.000000"/>

                    <label>Altitude:</label>
                    <input type="number" step="0.01" class="altitude" placeholder="100"/>

                    <button onclick="this.parentNode.remove()">üóë Remove</button>
                `;

                container.appendChild(div);
            }

            function sendData() {
                const droneId = document.getElementById("droneId").value.trim();
                const droneType = document.getElementById("droneType").value.trim();

                const telemetry = [];
                const blocks = document.querySelectorAll(".telemetry-block");

                blocks.forEach(block => {
                    const time = parseFloat(block.querySelector(".time").value);
                    const lon = parseFloat(block.querySelector(".longitude").value);
                    const lat = parseFloat(block.querySelector(".latitude").value);
                    const alt = parseFloat(block.querySelector(".altitude").value);

                    telemetry.push({
                        time: time,
                        position: [lon, lat],
                        altitude: alt
                    });
                });

                const payload = {
                    drone_id: droneId,
                    drone_type: droneType,
                    telemetry: telemetry
                };

                fetch("/api/drones/predict-path", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(payload)
                })
                    .then(response => response.json())
                    .then(data => {
                        document.getElementById("response").textContent = JSON.stringify(data, null, 2);

                        if (data.predictedPoints && data.predictedPoints.length > 0) {
                            window.predictedPath = data.predictedPoints.map(p => ({
                                time: p.secondsAhead,
                                position: [p.longitude, p.latitude],
                                altitude: p.altitude
                            }));

                            drawChart(window.predictedPath);
                        } else {
                            window.predictedPath = [];
                            alert("No predicted points received.");
                        }
                    })
                    .catch(err => {
                        document.getElementById("response").textContent = "Error: " + err;
                    });
            }


            function detectDroneType() {
                const droneId = document.getElementById("droneId").value.trim();
                const droneType = document.getElementById("droneType").value.trim();

                const telemetry = [];
                const blocks = document.querySelectorAll(".telemetry-block");

                blocks.forEach(block => {
                    const time = parseFloat(block.querySelector(".time").value);
                    const lon = parseFloat(block.querySelector(".longitude").value);
                    const lat = parseFloat(block.querySelector(".latitude").value);
                    const alt = parseFloat(block.querySelector(".altitude").value);

                    telemetry.push({
                        time: time,
                        position: [lon, lat],
                        altitude: alt
                    });
                });

                const payload = {
                    drone_id: droneId,
                    drone_type: droneType,
                    telemetry: telemetry
                };

                fetch("/api/drones/drone-type", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify(payload)
                })
                    .then(response => response.json())
                    .then(data => {
                        document.getElementById("response").textContent = JSON.stringify(data, null, 2);
                    })
                    .catch(err => {
                        document.getElementById("response").textContent = "Error: " + err;
                    });
            }

            function loadJsonFile() {
                const input = document.getElementById('jsonFileInput');
                if (!input.files || input.files.length === 0) {
                    alert('–í—ã–±–µ—Ä–∏—Ç–µ JSON —Ñ–∞–π–ª.');
                    return;
                }
                const file = input.files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.telemetry && Array.isArray(data.telemetry)) {
                            fillTelemetryBlocks(data.telemetry);
                            if (data.drone_id) document.getElementById('droneId').value = data.drone_id;
                            if (data.drone_type) document.getElementById('droneType').value = data.drone_type;
                        } else {
                            alert('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞: –Ω–µ—Ç telemetry.');
                        }
                    } catch (err) {
                        alert('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: ' + err);
                    }
                };
                reader.readAsText(file);
            }

            function fillTelemetryBlocks(telemetry) {
                const container = document.getElementById('telemetry-container');
                container.innerHTML = '';
                telemetry.forEach(point => {
                    const div = document.createElement('div');
                    div.className = 'telemetry-block';
                    div.innerHTML = `
                        <label>Time (seconds):</label>
                        <input type="number" step="0.01" class="time" value="${point.time}"/>
                        <label>Longitude:</label>
                        <input type="number" step="0.000001" class="longitude" value="${point.position[0]}"/>
                        <label>Latitude:</label>
                        <input type="number" step="0.000001" class="latitude" value="${point.position[1]}"/>
                        <label>Altitude:</label>
                        <input type="number" step="0.01" class="altitude" value="${point.altitude}"/>
                        <button onclick="this.parentNode.remove()">üóë Remove</button>
                    `;
                    container.appendChild(div);
                });
            }

            function collectAndCreateGraph() {

                if (window.replayInterval) {
                    clearInterval(window.replayInterval);
                    window.replayInterval = null;
                }
                document.getElementById("response").textContent = "Waiting...";

                const blocks = document.querySelectorAll(".telemetry-block");
                window.allTelemetry = [];
                blocks.forEach(block => {
                    const time = parseFloat(block.querySelector(".time").value);
                    const lon = parseFloat(block.querySelector(".longitude").value);
                    const lat = parseFloat(block.querySelector(".latitude").value);
                    const alt = parseFloat(block.querySelector(".altitude").value);
                    window.allTelemetry.push({
                        time: time,
                        position: [lon, lat],
                        altitude: alt
                    });
                });
                const droneId = document.getElementById("droneId").value.trim();
                const droneType = document.getElementById("droneType").value.trim();
                const method = document.getElementById('graphMethod').value;
                const pointsLimit = parseInt(document.getElementById('pointsLimit').value, 10);

                window.baseTelemetry = window.allTelemetry.slice(0, pointsLimit);
                window.generatedTelemetry = [...window.baseTelemetry];

                function sendAndUpdate() {
                    const payload = {
                        drone_id: droneId,
                        drone_type: droneType,
                        telemetry: window.generatedTelemetry,
                        method: method,
                        points_limit: window.generatedTelemetry.length
                    };
                    fetch("/api/drones/trajectory-visualization", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload)
                    })
                        .then(response => response.json())
                        .then(data => {
                            document.getElementById("response").textContent =
                              "Telemetry (" + window.generatedTelemetry.length + "):\n" +
                              JSON.stringify(window.generatedTelemetry, null, 2) +
                              "\n\nServer response:\n" +
                              JSON.stringify(data, null, 2);
                            drawTrajectoryGraph(data);
                        })
                        .catch(err => {
                            document.getElementById("response").textContent = "Error: " + err;
                        });
                }

                sendAndUpdate();

                window.replayInterval = setInterval(() => {
                    if (window.generatedTelemetry.length >= 30) {
                        clearInterval(window.replayInterval);
                        window.replayInterval = null;
                        return;
                    }

                    if (window.generatedTelemetry.length >= 2) {
                        const prev = window.generatedTelemetry[window.generatedTelemetry.length - 2];
                        const curr = window.generatedTelemetry[window.generatedTelemetry.length - 1];
                        const timeDiff = curr.time - prev.time;
                        let newTime = curr.time + (timeDiff > 0 ? timeDiff : 1);
                        const lonSpeed = (curr.position[0] - prev.position[0]) / (timeDiff > 0 ? timeDiff : 1);
                        const latSpeed = (curr.position[1] - prev.position[1]) / (timeDiff > 0 ? timeDiff : 1);
                        const altSpeed = (curr.altitude - prev.altitude) / (timeDiff > 0 ? timeDiff : 1);
                        const newPoint = {
                            time: newTime,
                            position: [curr.position[0] + lonSpeed * (timeDiff > 0 ? timeDiff : 1), curr.position[1] + latSpeed * (timeDiff > 0 ? timeDiff : 1)],
                            altitude: curr.altitude + altSpeed * (timeDiff > 0 ? timeDiff : 1)
                        };
                        window.generatedTelemetry.push(newPoint);
                    }
                    sendAndUpdate();
                }, 1000);
            }

            function stopCalculation() {
                if (window.replayInterval) {
                    clearInterval(window.replayInterval);
                    window.replayInterval = null;
                }
            }

            function drawTrajectoryGraph(data) {
                const ctx = document.getElementById('deviationChart').getContext('2d');
                const current = data.currentTrajectory || [];
                const forecast = data.forecast || [];
                const real = data.realContinuation || [];
                const makeXY = arr => arr.map(p => ({x: p.longitude, y: p.latitude}));
                const datasets = [];
                if (current.length > 0) {
                    datasets.push({
                        label: '–¢–µ–∫—É—â–∞—è —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏—è',
                        data: makeXY(current),
                        borderColor: 'blue',
                        backgroundColor: 'rgba(0,0,255,0.1)',
                        fill: false,
                        tension: 0.1
                    });
                }
                if (forecast.length > 0) {
                    datasets.push({
                        label: '–ü—Ä–æ–≥–Ω–æ–∑',
                        data: makeXY(forecast),
                        borderColor: 'orange',
                        backgroundColor: 'rgba(255,165,0,0.1)',
                        borderDash: [5,5],
                        fill: false,
                        tension: 0.1
                    });
                }
                if (real.length > 0) {
                    datasets.push({
                        label: '–†–µ–∞–ª—å–Ω–æ–µ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ',
                        data: makeXY(real),
                        borderColor: 'green',
                        backgroundColor: 'rgba(0,255,0,0.1)',
                        borderDash: [2,2],
                        fill: false,
                        tension: 0.1
                    });
                }
                if (window.trajectoryChart) {
                    window.trajectoryChart.destroy();
                }
                window.trajectoryChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: false,
                        plugins: {
                            legend: { display: true }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                title: { display: true, text: '–î–æ–ª–≥–æ—Ç–∞' }
                            },
                            y: {
                                type: 'linear',
                                title: { display: true, text: '–®–∏—Ä–æ—Ç–∞' }
                            }
                        }
                    }
                });
                drawDeviationGraph(forecast, real);
                drawRealtimeDeviationGraph(forecast, real);
                update3DVisualization(data);
            }

            function drawChart(predictedPoints) {
                const ctx = document.getElementById('deviationChart').getContext('2d');

                if (window.myChart) {
                    window.myChart.destroy();
                }

                const labels = predictedPoints.map(p => p.time);
                const lonData = predictedPoints.map(p => p.position[0]);
                const latData = predictedPoints.map(p => p.position[1]);
                const altData = predictedPoints.map(p => p.altitude);

                window.myChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Longitude',
                                data: lonData,
                                borderColor: 'rgb(75, 192, 192)',
                                tension: 0.1
                            },
                            {
                                label: 'Latitude',
                                data: latData,
                                borderColor: 'rgb(54, 162, 235)',
                                tension: 0.1
                            },
                            {
                                label: 'Altitude',
                                data: altData,
                                borderColor: 'rgb(255, 99, 132)',
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                beginAtZero: false
                            }
                        }
                    }
                });
            }

            function haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371000;
                const toRad = deg => deg * Math.PI / 180;
                const dLat = toRad(lat2 - lat1);
                const dLon = toRad(lon2 - lon1);
                const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            function drawDeviationGraph(forecast, real) {
                const ctx = document.getElementById('forecastDeviationChart').getContext('2d');
                const deviation = [];
                const altDeviation = [];
                const labels = [];
                for (let i = 0; i < Math.min(forecast.length, real.length); i++) {
                    const f = forecast[i];
                    const r = real[i];
                    const dist = haversineDistance(f.latitude, f.longitude, r.latitude, r.longitude);
                    const altDev = Math.abs(f.altitude - r.altitude);
                    deviation.push(dist);
                    altDeviation.push(altDev);
                    labels.push(f.secondsAhead || f.time || i+1);
                }
                if (window.forecastDeviationChart && typeof window.forecastDeviationChart.destroy === 'function') {
                    window.forecastDeviationChart.destroy();
                }
                window.forecastDeviationChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: '–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ (–º)',
                                data: deviation,
                                borderColor: 'red',
                                fill: false,
                                tension: 0.1
                            },
                            {
                                label: '–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –ø–æ –≤—ã—Å–æ—Ç–µ (–º)',
                                data: altDeviation,
                                borderColor: 'purple',
                                fill: false,
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: false,
                        plugins: {
                            legend: { display: true }
                        },
                        scales: {
                            x: {
                                title: { display: true, text: '–í—Ä–µ–º—è (—Å–µ–∫)' }
                            },
                            y: {
                                title: { display: true, text: '–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ (–º)' }
                            }
                        }
                    }
                });
            }

            function drawRealtimeDeviationGraph(forecast, real) {
                const ctx = document.getElementById('realtimeDeviationChart').getContext('2d');
                const deviation = [];
                const altDeviation = [];
                const labels = [];
                for (let i = forecast.length; i < real.length; i++) {
                    const r = real[i];
                    const f = forecast[forecast.length - 1];
                    const dist = haversineDistance(f.latitude, f.longitude, r.latitude, r.longitude);
                    const altDev = Math.abs(f.altitude - r.altitude);
                    deviation.push(dist);
                    altDeviation.push(altDev);
                    labels.push(r.secondsAhead || r.time || i+1);
                }
                if (window.realtimeDeviationChart && typeof window.realtimeDeviationChart.destroy === 'function') {
                    window.realtimeDeviationChart.destroy();
                }
                window.realtimeDeviationChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: '–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ (–º) ‚Äî –Ω–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã',
                                data: deviation,
                                borderColor: 'darkred',
                                fill: false,
                                tension: 0.1
                            },
                            {
                                label: '–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –ø–æ –≤—ã—Å–æ—Ç–µ (–º) ‚Äî –Ω–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã',
                                data: altDeviation,
                                borderColor: 'darkmagenta',
                                fill: false,
                                tension: 0.1
                            }
                        ]
                    },
                    options: {
                        responsive: false,
                        plugins: {
                            legend: { display: true }
                        },
                        scales: {
                            x: {
                                title: { display: true, text: '–í—Ä–µ–º—è (—Å–µ–∫)' }
                            },
                            y: {
                                title: { display: true, text: '–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ (–º)' }
                            }
                        }
                    }
                });
            }

            let scene, camera, renderer, controls;
            let drone, trajectory, forecastTrajectory, realTrajectory;
            let animationId;
            let isAnimating = true;
            let animationSpeed = 1;
            let currentPointIndex = 0;
            let allPoints = [];

            function init3DVisualization() {
                const container = document.getElementById('3d-container');
                const canvas = document.getElementById('3dCanvas');

                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);

                camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.set(0, 50, 100);

                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;

                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                createAxes();

                createGridWithLabels();

                const droneGeometry = new THREE.BoxGeometry(2, 1, 2);
                const droneMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
                drone = new THREE.Mesh(droneGeometry, droneMaterial);
                drone.castShadow = true;
                scene.add(drone);
                
                animate();
            }
            
            function update3DVisualization(data) {
                const current = data.currentTrajectory || [];
                const forecast = data.forecast || [];
                const real = data.realContinuation || [];

                if (trajectory) scene.remove(trajectory);
                if (forecastTrajectory) scene.remove(forecastTrajectory);
                if (realTrajectory) scene.remove(realTrajectory);

                allPoints = [];

                current.forEach(point => {
                    allPoints.push({
                        x: (point.longitude - 37.617) * 100000,
                        y: point.altitude,
                        z: (point.latitude - 55.755) * 100000,
                        type: 'current'
                    });
                });

                forecast.forEach(point => {
                    allPoints.push({
                        x: (point.longitude - 37.617) * 100000,
                        y: point.altitude,
                        z: (point.latitude - 55.755) * 100000,
                        type: 'forecast'
                    });
                });

                real.forEach(point => {
                    allPoints.push({
                        x: (point.longitude - 37.617) * 100000,
                        y: point.altitude,
                        z: (point.latitude - 55.755) * 100000,
                        type: 'real'
                    });
                });

                createTrajectoryLines(current, forecast, real);

                currentPointIndex = 0;
                if (allPoints.length > 0) {
                    updateDronePosition(allPoints[0]);
                }
            }
            
            function createTrajectoryLines(current, forecast, real) {

                if (current.length > 1) {
                    const currentGeometry = new THREE.BufferGeometry();
                    const currentPoints = current.map(p => new THREE.Vector3(
                        (p.longitude - 37.617) * 100000,
                        p.altitude,
                        (p.latitude - 55.755) * 100000
                    ));
                    currentGeometry.setFromPoints(currentPoints);
                    const currentMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 3 });
                    trajectory = new THREE.Line(currentGeometry, currentMaterial);
                    scene.add(trajectory);
                }

                if (forecast.length > 1) {
                    const forecastGeometry = new THREE.BufferGeometry();
                    const forecastPoints = forecast.map(p => new THREE.Vector3(
                        (p.longitude - 37.617) * 100000,
                        p.altitude,
                        (p.latitude - 55.755) * 100000
                    ));
                    forecastGeometry.setFromPoints(forecastPoints);
                    const forecastMaterial = new THREE.LineDashedMaterial({ 
                        color: 0xff6600, 
                        dashSize: 3, 
                        gapSize: 2 
                    });
                    forecastTrajectory = new THREE.Line(forecastGeometry, forecastMaterial);
                    forecastTrajectory.computeLineDistances();
                    scene.add(forecastTrajectory);
                }

                if (real.length > 1) {
                    const realGeometry = new THREE.BufferGeometry();
                    const realPoints = real.map(p => new THREE.Vector3(
                        (p.longitude - 37.617) * 100000,
                        p.altitude,
                        (p.latitude - 55.755) * 100000
                    ));
                    realGeometry.setFromPoints(realPoints);
                    const realMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
                    realTrajectory = new THREE.Line(realGeometry, realMaterial);
                    scene.add(realTrajectory);
                }
            }
            
            function updateDronePosition(point) {
                drone.position.set(point.x, point.y, point.z);

                const realLongitude = (point.x / 100000) + 37.617;
                const realLatitude = (point.z / 100000) + 55.755;
                const realAltitude = point.y;

                const coordsElement = document.getElementById('drone-coordinates');
                coordsElement.innerHTML = `
                    <span style="color: #ff0000;">–î–æ–ª–≥–æ—Ç–∞: ${realLongitude.toFixed(6)}</span><br>
                    <span style="color: #00ff00;">–í—ã—Å–æ—Ç–∞: ${realAltitude.toFixed(2)} –º</span><br>
                    <span style="color: #0000ff;">–®–∏—Ä–æ—Ç–∞: ${realLatitude.toFixed(6)}</span>
                `;
            }
            
            function animate() {
                animationId = requestAnimationFrame(animate);
                
                if (isAnimating && allPoints.length > 0) {
                    currentPointIndex += 0.01 * animationSpeed;
                    if (currentPointIndex >= allPoints.length) {
                        currentPointIndex = 0;
                    }
                    
                    const point = allPoints[Math.floor(currentPointIndex)];
                    if (point) {
                        updateDronePosition(point);
                    }
                }
                
                controls.update();
                renderer.render(scene, camera);
            }
            
            function resetCamera() {
                camera.position.set(0, 50, 100);
                camera.lookAt(0, 0, 0);
                controls.reset();
            }
            
            function toggleAnimation() {
                isAnimating = !isAnimating;
            }
            
            function updateAnimationSpeed() {
                animationSpeed = parseFloat(document.getElementById('animationSpeed').value);
            }

            function refresh3DVisualization() {
                const blocks = document.querySelectorAll(".telemetry-block");
                const telemetry = [];
                blocks.forEach(block => {
                    const time = parseFloat(block.querySelector(".time").value);
                    const lon = parseFloat(block.querySelector(".longitude").value);
                    const lat = parseFloat(block.querySelector(".latitude").value);
                    const alt = parseFloat(block.querySelector(".altitude").value);
                    telemetry.push({
                        time: time,
                        position: [lon, lat],
                        altitude: alt
                    });
                });
                const droneId = document.getElementById("droneId").value.trim();
                const droneType = document.getElementById("droneType").value.trim();

                const payload = {
                    drone_id: droneId,
                    drone_type: droneType,
                    telemetry: telemetry
                };

                fetch("/api/drones/trajectory-visualization", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload)
                })
                    .then(response => response.json())
                    .then(data => {
                        update3DVisualization(data);
                        alert("3D –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞.");
                    })
                    .catch(err => {
                        alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ 3D –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏: " + err);
                    });
            }

            function createAxes() {

                const axisLength = 150;
                const axisWidth = 2;

                const xGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(axisLength, 0, 0)
                ]);
                const xMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: axisWidth });
                const xAxis = new THREE.Line(xGeometry, xMaterial);
                scene.add(xAxis);

                const yGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, axisLength, 0)
                ]);
                const yMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: axisWidth });
                const yAxis = new THREE.Line(yGeometry, yMaterial);
                scene.add(yAxis);

                const zGeometry = new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(0, 0, axisLength)
                ]);
                const zMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: axisWidth });
                const zAxis = new THREE.Line(zGeometry, zMaterial);
                scene.add(zAxis);

                addAxisLabels();
            }
            
            function addAxisLabels() {

                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;

                function createTextTexture(text, color) {
                    context.fillStyle = '#000000';
                    context.fillRect(0, 0, canvas.width, canvas.height);
                    context.fillStyle = color;
                    context.font = '48px Arial';
                    context.textAlign = 'center';
                    context.fillText(text, canvas.width / 2, canvas.height / 2 + 8);
                    
                    const texture = new THREE.CanvasTexture(canvas);
                    return texture;
                }

                const xLabel = createTextTexture('X (–î–æ–ª–≥–æ—Ç–∞)', '#ff0000');
                const yLabel = createTextTexture('Y (–í—ã—Å–æ—Ç–∞)', '#00ff00');
                const zLabel = createTextTexture('Z (–®–∏—Ä–æ—Ç–∞)', '#0000ff');

                const spriteMaterialX = new THREE.SpriteMaterial({ map: xLabel });
                const spriteX = new THREE.Sprite(spriteMaterialX);
                spriteX.position.set(160, 0, 0);
                spriteX.scale.set(20, 5, 1);
                scene.add(spriteX);
                
                const spriteMaterialY = new THREE.SpriteMaterial({ map: yLabel });
                const spriteY = new THREE.Sprite(spriteMaterialY);
                spriteY.position.set(0, 160, 0);
                spriteY.scale.set(20, 5, 1);
                scene.add(spriteY);
                
                const spriteMaterialZ = new THREE.SpriteMaterial({ map: zLabel });
                const spriteZ = new THREE.Sprite(spriteMaterialZ);
                spriteZ.position.set(0, 0, 160);
                spriteZ.scale.set(20, 5, 1);
                scene.add(spriteZ);
            }

            function createGridWithLabels() {
                const gridHelper = new THREE.GridHelper(200, 20, 0x888888, 0xcccccc);
                scene.add(gridHelper);
            }

            window.addEventListener('DOMContentLoaded', () => {
                const ctx1 = document.getElementById('deviationChart').getContext('2d');
                window.trajectoryChart = new Chart(ctx1, {
                    type: 'line',
                    data: { datasets: [] },
                    options: {
                        responsive: false,
                        plugins: { legend: { display: true } },
                        scales: {
                            x: { type: 'linear', title: { display: true, text: '–î–æ–ª–≥–æ—Ç–∞' } },
                            y: { type: 'linear', title: { display: true, text: '–®–∏—Ä–æ—Ç–∞' } }
                        }
                    }
                });

                const ctx2 = document.getElementById('forecastDeviationChart').getContext('2d');
                window.forecastDeviationChart = new Chart(ctx2, {
                    type: 'line',
                    data: { labels: [], datasets: [
                        { label: '–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ (–º)', data: [], borderColor: 'red', fill: false, tension: 0.1 },
                        { label: '–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –ø–æ –≤—ã—Å–æ—Ç–µ (–º)', data: [], borderColor: 'purple', fill: false, tension: 0.1 }
                    ] },
                    options: {
                        responsive: false,
                        plugins: { legend: { display: true } },
                        scales: {
                            x: { title: { display: true, text: '–í—Ä–µ–º—è (—Å–µ–∫)' } },
                            y: { title: { display: true, text: '–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ (–º)' } }
                        }
                    }
                });

                const ctx3 = document.getElementById('realtimeDeviationChart').getContext('2d');
                window.realtimeDeviationChart = new Chart(ctx3, {
                    type: 'line',
                    data: { labels: [], datasets: [
                        { label: '–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ (–º) ‚Äî –Ω–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã', data: [], borderColor: 'darkred', fill: false, tension: 0.1 },
                        { label: '–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –ø–æ –≤—ã—Å–æ—Ç–µ (–º) ‚Äî –Ω–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã', data: [], borderColor: 'darkmagenta', fill: false, tension: 0.1 }
                    ] },
                    options: {
                        responsive: false,
                        plugins: { legend: { display: true } },
                        scales: {
                            x: { title: { display: true, text: '–í—Ä–µ–º—è (—Å–µ–∫)' } },
                            y: { title: { display: true, text: '–û—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ (–º)' } }
                        }
                    }
                });
                

                
                                init3DVisualization();
            });
        </script>

    </body>
</html>
